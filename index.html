<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Emotion Recognition System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --bg-tertiary: #1a2332;
            --accent-primary: #00d4ff;
            --accent-secondary: #7c3aed;
            --accent-glow: rgba(0, 212, 255, 0.3);
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: rgba(148, 163, 184, 0.1);
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f1419 100%);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 212, 255, 0.05) 0%, transparent 50%);
            animation: rotate 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .app-container {
            display: flex;
            height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* Left side - Camera view */
        .camera-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 0 8px;
        }

        .logo {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 0 20px var(--accent-glow);
        }

        .title-group h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), #fff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .title-group p {
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .video-wrapper {
            flex: 1;
            position: relative;
            background: var(--bg-secondary);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .video-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
            z-index: 2;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .video-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 12px;
            z-index: 10;
        }

        .overlay-badge {
            padding: 8px 16px;
            background: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Right sidebar - Controls and Stats */
        .sidebar {
            width: 380px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-section {
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-section:last-child {
            border-bottom: none;
        }

        .section-title {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::before {
            content: '';
            width: 3px;
            height: 12px;
            background: linear-gradient(180deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 2px;
        }

        /* Controls */
        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 10px;
            display: block;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            box-shadow: 0 4px 15px var(--accent-glow);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--accent-glow);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        .radio-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .radio-option {
            flex: 1;
            min-width: 0;
        }

        .radio-option input[type="radio"] {
            display: none;
        }

        .radio-option label {
            display: block;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .radio-option input[type="radio"]:checked + label {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(124, 58, 237, 0.1));
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .slider-control {
            margin-top: 8px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .slider-value {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-primary);
            padding: 4px 10px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 6px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px var(--accent-glow);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px var(--accent-glow);
            border: none;
        }

        /* Toggle Switch */
        .toggle-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input[type="checkbox"] {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            transition: 0.4s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: var(--text-muted);
            transition: 0.4s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(124, 58, 237, 0.2));
            border-color: var(--accent-primary);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            box-shadow: 0 2px 8px var(--accent-glow);
        }

        /* Stats */
        .stats-grid {
            display: grid;
            gap: 12px;
        }

        .stat-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateX(4px);
        }

        .stat-label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stat-card.highlight .stat-value {
            color: var(--accent-primary);
        }

        .stat-card.nested {
            padding-left: 26px;
            background: rgba(26, 35, 50, 0.5);
        }

        .stat-card.nested .stat-label::before {
            content: '‚îî';
            margin-right: 6px;
            color: var(--text-muted);
        }

        /* Error message */
        .error-msg {
            margin: 20px;
            padding: 16px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--error);
            border-radius: 12px;
            color: var(--error);
            font-size: 14px;
            display: none;
        }

        /* Scrollbar styling */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .app-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                border-left: none;
                border-top: 1px solid var(--border-color);
                max-height: 400px;
            }
        }

        @media (max-width: 768px) {
            .camera-section {
                padding: 12px;
            }

            .sidebar-section {
                padding: 16px;
            }

            .header {
                gap: 12px;
            }

            .logo {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }

            .title-group h1 {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Left side - Camera view -->
        <div class="camera-section">
            <div class="header">
                <div class="logo">üé≠</div>
                <div class="title-group">
                    <h1>Face Emotion Recognition</h1>
                    <p>Real-time AI-powered facial analysis</p>
                </div>
            </div>

            <div id="errorMsg" class="error-msg"></div>

            <div class="video-wrapper">
                <div class="video-overlay">
                    <div class="overlay-badge">
                        <span class="status-dot"></span>
                        <span id="statusBadge">Standby</span>
                    </div>
                    <div class="overlay-badge">
                        <span>üéØ</span>
                        <span id="faceCountBadge">0 faces</span>
                    </div>
                </div>
                <div class="video-container">
                    <video id="webcam" autoplay playsinline></video>
                    <canvas id="canvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Right sidebar - Controls and Stats -->
        <div class="sidebar">
            <!-- Controls Section -->
            <div class="sidebar-section">
                <div class="section-title">Controls</div>
                
                <div class="control-group">
                    <div class="button-group">
                        <button id="startBtn" class="btn btn-primary">‚ñ∂ Start Camera</button>
                        <button id="stopBtn" class="btn btn-secondary" disabled>‚è∏ Stop</button>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Backend Engine</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" name="backend" value="wasm" id="backend-wasm" checked>
                            <label for="backend-wasm">WASM</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" name="backend" value="js" id="backend-js">
                            <label for="backend-js">JavaScript</label>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Display Mode</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" name="displayMode" value="normal" id="mode-normal" checked>
                            <label for="mode-normal">Filter</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" name="displayMode" value="flower" id="mode-flower">
                            <label for="mode-flower">Flower</label>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="slider-control">
                        <div class="slider-header">
                            <label class="control-label" style="margin: 0;">Flower Count</label>
                            <span class="slider-value" id="flowerCountValue">10</span>
                        </div>
                        <input type="range" id="flowerCountSlider" min="5" max="20" value="10">
                    </div>
                </div>

                <div class="control-group">
                    <div class="toggle-control">
                        <label class="control-label" style="margin: 0;">Show Landmarks</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="showLandmarksToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Performance Stats Section -->
            <div class="sidebar-section">
                <div class="section-title">Performance</div>
                <div class="stats-grid">
                    <div class="stat-card highlight">
                        <span class="stat-label">Status</span>
                        <span class="stat-value" id="status">Standby</span>
                    </div>
                    <div class="stat-card highlight">
                        <span class="stat-label">Latency</span>
                        <span class="stat-value" id="latency">0 ms</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">Backend</span>
                        <span class="stat-value" id="backendType">WASM</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">Processing Time</span>
                        <span class="stat-value" id="processingTime">0 ms</span>
                    </div>
                    <div class="stat-card nested">
                        <span class="stat-label">Transform</span>
                        <span class="stat-value" id="landmarkTransformTime">0 ms</span>
                    </div>
                    <div class="stat-card nested">
                        <span class="stat-label">Neural Net</span>
                        <span class="stat-value" id="neuralNetworkTime">0 ms</span>
                    </div>
                    <div class="stat-card nested">
                        <span class="stat-label">Emoji Overlay</span>
                        <span class="stat-value" id="emojiOverlayTime">0 ms</span>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script src="./wasm/expression_recognition.js"></script>
    <script type="module">
        import { processFrameJS, initJSBackend } from './js/expression_backend.js';
        
        // Ï†ÑÏó≠ Í∞ùÏ≤¥Î°ú Í¥ÄÎ¶¨
        window.appState = {
            expressionModule: null,
            wasmReady: false,
            jsBackendReady: false,
            currentBackend: 'wasm',
            displayMode: 'normal',  // 'normal' or 'flower'
            flowerCount: 10,  // 5-20
            showLandmarks: true,  // ÎûúÎìúÎßàÌÅ¨ ÏãúÍ∞ÅÌôî Ïó¨Î∂Ä
            // WASM Î©îÎ™®Î¶¨ ÌíÄÎßÅ
            wasmMemory: {
                imagePtr: null,
                imageSize: 0,
                landmarksPtr: null,
                landmarksSize: 0,
                latencyTablePtr: null,
                latencyTableSize: 0,
                maxFaces: 5,  // MediaPipe ÏÑ§Ï†ïÍ≥º ÎèôÏùº
                maxLandmarks: 478  // MediaPipe face landmark Ïàò
            }
        };
        
        // JS Backend Ï¥àÍ∏∞Ìôî
        try {
            window.appState.jsBackendReady = initJSBackend();
            console.log('JS Backend Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
        } catch (error) {
            console.error('JS Backend Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
        }

        // WASM Î©îÎ™®Î¶¨ Ìï†Îãπ/Ìï¥Ï†ú Ìó¨Ìçº Ìï®Ïàò
        function allocateWASMMemory(width, height, numFaces, numLandmarks) {
            const mem = window.appState.wasmMemory;
            const Module = window.appState.expressionModule;
            
            if (!Module) return false;
            
            // Ïù¥ÎØ∏ÏßÄ Î©îÎ™®Î¶¨ Ìï†Îãπ/Ïû¨Ìï†Îãπ
            const imageSize = width * height * 4;
            if (!mem.imagePtr || mem.imageSize < imageSize) {
                // Í∏∞Ï°¥ Î©îÎ™®Î¶¨ Ìï¥Ï†ú
                if (mem.imagePtr) {
                    Module._free(mem.imagePtr);
                }
                // ÏÉàÎ°úÏö¥ Î©îÎ™®Î¶¨ Ìï†Îãπ
                mem.imagePtr = Module._malloc(imageSize);
                mem.imageSize = imageSize;
                if (!mem.imagePtr) {
                    console.error('Ïù¥ÎØ∏ÏßÄ Î©îÎ™®Î¶¨ Ìï†Îãπ Ïã§Ìå®');
                    return false;
                }
            }
            
            // ÎûúÎìúÎßàÌÅ¨ Î©îÎ™®Î¶¨ Ìï†Îãπ/Ïû¨Ìï†Îãπ (ÏµúÎåÄ ÌÅ¨Í∏∞Î°ú ÎØ∏Î¶¨ Ìï†Îãπ)
            const maxLandmarksSize = mem.maxFaces * mem.maxLandmarks * 2 * Float32Array.BYTES_PER_ELEMENT;
            if (!mem.landmarksPtr || mem.landmarksSize < maxLandmarksSize) {
                // Í∏∞Ï°¥ Î©îÎ™®Î¶¨ Ìï¥Ï†ú
                if (mem.landmarksPtr) {
                    Module._free(mem.landmarksPtr);
                }
                // ÏµúÎåÄ ÌÅ¨Í∏∞Î°ú Ìï†Îãπ (Ïû¨ÏÇ¨Ïö©ÏùÑ ÏúÑÌï¥)
                mem.landmarksPtr = Module._malloc(maxLandmarksSize);
                mem.landmarksSize = maxLandmarksSize;
                if (!mem.landmarksPtr) {
                    console.error('ÎûúÎìúÎßàÌÅ¨ Î©îÎ™®Î¶¨ Ìï†Îãπ Ïã§Ìå®');
                    // Ïù¥ÎØ∏ÏßÄ Î©îÎ™®Î¶¨Îäî Ïù¥ÎØ∏ Ìï†ÎãπÎêòÏóàÏúºÎØÄÎ°ú Ìï¥Ï†ú
                    if (mem.imagePtr) {
                        Module._free(mem.imagePtr);
                        mem.imagePtr = null;
                    }
                    return false;
                }
            }
            
            // Î†àÏù¥ÌÑ¥Ïãú ÌÖåÏù¥Î∏î Î©îÎ™®Î¶¨ Ìï†Îãπ (3Í∞ú int)
            const latencyTableSize = 3 * Int32Array.BYTES_PER_ELEMENT;
            if (!mem.latencyTablePtr || mem.latencyTableSize < latencyTableSize) {
                // Í∏∞Ï°¥ Î©îÎ™®Î¶¨ Ìï¥Ï†ú
                if (mem.latencyTablePtr) {
                    Module._free(mem.latencyTablePtr);
                }
                // Ìï†Îãπ
                mem.latencyTablePtr = Module._malloc(latencyTableSize);
                mem.latencyTableSize = latencyTableSize;
                if (!mem.latencyTablePtr) {
                    console.error('Î†àÏù¥ÌÑ¥Ïãú ÌÖåÏù¥Î∏î Î©îÎ™®Î¶¨ Ìï†Îãπ Ïã§Ìå®');
                    return false;
                }
            }
            
            return true;
        }
        
        // WASM Î©îÎ™®Î¶¨ Ìï¥Ï†ú Ìï®Ïàò
        function freeWASMMemory() {
            const mem = window.appState.wasmMemory;
            const Module = window.appState.expressionModule;
            
            if (Module) {
                if (mem.imagePtr) {
                    Module._free(mem.imagePtr);
                    mem.imagePtr = null;
                }
                if (mem.landmarksPtr) {
                    Module._free(mem.landmarksPtr);
                    mem.landmarksPtr = null;
                }
                if (mem.latencyTablePtr) {
                    Module._free(mem.latencyTablePtr);
                    mem.latencyTablePtr = null;
                }
            }
            
            mem.imageSize = 0;
            mem.landmarksSize = 0;
            mem.latencyTableSize = 0;
        }

        // WASM Î™®Îìà Ï¥àÍ∏∞Ìôî
        createExpressionRecognitionModule().then(function(Module) {
            window.appState.expressionModule = Module;
            window.appState.wasmReady = true;
            console.log('WASM Î™®Îìà Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
        }).catch(function(error) {
            console.error('WASM Î™®Îìà Î°úÎìú Ïã§Ìå®:', error);
        });
        
        // Î∞±ÏóîÎìú ÏÑ†ÌÉù Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.querySelectorAll('input[name="backend"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const oldBackend = window.appState.currentBackend;
                window.appState.currentBackend = this.value;
                document.getElementById('backendType').textContent = 
                    window.appState.currentBackend === 'wasm' ? 'WASM' : 'JavaScript';
                console.log('Î∞±ÏóîÎìú Î≥ÄÍ≤Ω:', window.appState.currentBackend);
                
                // WASMÏóêÏÑú Îã§Î•∏ Î∞±ÏóîÎìúÎ°ú Î≥ÄÍ≤Ω Ïãú Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ (ÏÑ†ÌÉùÏ†Å)
                // if (oldBackend === 'wasm' && this.value !== 'wasm') {
                //     freeWASMMemory();
                // }
            });
        });
        
        // ÌëúÏãú Î™®Îìú ÏÑ†ÌÉù Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.querySelectorAll('input[name="displayMode"]').forEach(radio => {
            radio.addEventListener('change', function() {
                window.appState.displayMode = this.value;
                console.log('ÌëúÏãú Î™®Îìú Î≥ÄÍ≤Ω:', window.appState.displayMode);
            });
        });
        
        // ÍΩÉ Í∞ØÏàò Ïä¨ÎùºÏù¥Îçî Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.getElementById('flowerCountSlider').addEventListener('input', function() {
            window.appState.flowerCount = parseInt(this.value);
            document.getElementById('flowerCountValue').textContent = this.value;
        });
        
        // ÎûúÎìúÎßàÌÅ¨ ÏãúÍ∞ÅÌôî ÌÜ†Í∏Ä Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.getElementById('showLandmarksToggle').addEventListener('change', function() {
            window.appState.showLandmarks = this.checked;
            console.log('ÎûúÎìúÎßàÌÅ¨ ÏãúÍ∞ÅÌôî:', window.appState.showLandmarks ? 'ÏºúÏßê' : 'Í∫ºÏßê');
        });

        function processFrameWASM(imageData, faces) {
            if (!window.appState.wasmReady || !window.appState.expressionModule) {
                return { latency: 0, imageData: null, latencyTable: [0, 0, 0] };
            }

            if (!faces || faces.length === 0) {
                return { latency: 0, imageData: null, latencyTable: [0, 0, 0] };
            }

            if (!imageData || !imageData.data) {
                return { latency: 0, imageData: null, latencyTable: [0, 0, 0] };
            }

            const width = imageData.width;
            const height = imageData.height;
            const numFaces = faces.length;
            const numLandmarks = faces[0].length;

            // Î©îÎ™®Î¶¨ ÌíÄÏóêÏÑú Ìï†Îãπ (ÌïÑÏöîÏãúÏóêÎßå Ïû¨Ìï†Îãπ)
            if (!allocateWASMMemory(width, height, numFaces, numLandmarks)) {
                return { latency: 0, imageData: null, latencyTable: [0, 0, 0] };
            }

            const mem = window.appState.wasmMemory;
            const Module = window.appState.expressionModule;
            const imageSize = width * height * 4;

            // RGBA Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞Î•º WASM Î©îÎ™®Î¶¨Ïóê Î≥µÏÇ¨ (Í∏∞Ï°¥ Ìï†ÎãπÎêú Î©îÎ™®Î¶¨ ÏÇ¨Ïö©)
            Module.HEAPU8.set(imageData.data, mem.imagePtr);

            // ÎûúÎìúÎßàÌÅ¨ Îç∞Ïù¥ÌÑ∞Î•º Î©îÎ™®Î¶¨Ïóê ÏßÅÏ†ë ÏûëÏÑ± (Í∏∞Ï°¥ Ìï†ÎãπÎêú Î©îÎ™®Î¶¨ ÏÇ¨Ïö©)
            const landmarksHeap = Module.HEAPF32;
            const landmarksOffset = mem.landmarksPtr / Float32Array.BYTES_PER_ELEMENT;
            
            let idx = 0;
            for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
                const face = faces[faceIndex];
                for (let landmarkIndex = 0; landmarkIndex < numLandmarks; landmarkIndex++) {
                    const landmark = face[landmarkIndex];
                    landmarksHeap[landmarksOffset + idx++] = landmark.x;
                    landmarksHeap[landmarksOffset + idx++] = landmark.y;
                }
            }

            // ccallÏóê ÎåÄÌï¥ÏÑúÎßå Î†àÏù¥ÌÑ¥Ïãú Ï∏°Ï†ï
            const aroundFaceCount = window.appState.displayMode === 'flower' ? window.appState.flowerCount : 0;
            const ccallStart = performance.now();
            Module.ccall(
                'process_frame',
                null,
                ['number', 'number', 'number', 'number', 'number', 'number', 'number'],
                [mem.imagePtr, width, height, mem.landmarksPtr, numFaces, aroundFaceCount, mem.latencyTablePtr]
            );
            const ccallLatency = performance.now() - ccallStart;

            // Î†àÏù¥ÌÑ¥Ïãú ÌÖåÏù¥Î∏î ÏùΩÍ∏∞
            const latencyTableHeap = Module.HEAP32;
            const latencyTableOffset = mem.latencyTablePtr / Int32Array.BYTES_PER_ELEMENT;
            const latencyTable = [
                latencyTableHeap[latencyTableOffset],     // ÎûúÎìúÎßàÌÅ¨ Î≥ÄÌôò ÏãúÍ∞Ñ (ÎßàÏù¥ÌÅ¨Î°úÏ¥à)
                latencyTableHeap[latencyTableOffset + 1], // Ïã†Í≤ΩÎßù Ï∂îÎ°† ÏãúÍ∞Ñ (ÎßàÏù¥ÌÅ¨Î°úÏ¥à)
                latencyTableHeap[latencyTableOffset + 2]  // Emoji Ïò§Î≤ÑÎ†àÏù¥ ÏãúÍ∞Ñ (ÎßàÏù¥ÌÅ¨Î°úÏ¥à)
            ];

            // WASM Î©îÎ™®Î¶¨ÏóêÏÑú ÏßÅÏ†ë subarray ÏÇ¨Ïö© (Î≥µÏÇ¨ ÏµúÏÜåÌôî)
            const processedData = Module.HEAPU8.subarray(mem.imagePtr, mem.imagePtr + imageSize);
            
            // Í∏∞Ï°¥ imageData.dataÎ•º ÏßÅÏ†ë ÏàòÏ†ï (ÏÉàÎ°úÏö¥ ImageData ÏÉùÏÑ± Ïò§Î≤ÑÌó§Îìú Ï†úÍ±∞)
            imageData.data.set(processedData);
            
            return { latency: ccallLatency, imageData: imageData, latencyTable: latencyTable };
        }
        
        // Î∞±ÏóîÎìúÏóê Îî∞Îùº Ï†ÅÏ†àÌïú Ìï®Ïàò Ìò∏Ï∂ú
        function processFrame(imageData, faces) {
            if (window.appState.currentBackend === 'wasm') {
                return processFrameWASM(imageData, faces);
            } else {
                // JS Î∞±ÏóîÎìúÎäî emotionÎßå Î∞òÌôòÌïòÎØÄÎ°ú Î≥ÑÎèÑ Ï≤òÎ¶¨
                return { latency: 0, imageData: null };
            }
        }
        
        // Export to window for non-module scripts
        window.processFrame = processFrame;
        window.processFrameJS = processFrameJS;
    </script>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs';

        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const errorMsg = document.getElementById('errorMsg');

        let faceLandmarker;
        let animationId;
        let lastVideoTime = -1;
        let latencyHistory = [];

        // MediaPipe Ï¥àÍ∏∞Ìôî
        async function initMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
                );
                
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: false,
                    outputFacialTransformationMatrixes: false,
                    runningMode: 'VIDEO',
                    numFaces: 5
                });

                document.getElementById('status').textContent = 'Ready';
                document.getElementById('statusBadge').textContent = 'Ready';
                startBtn.disabled = false;
            } catch (error) {
                showError('MediaPipe Ï¥àÍ∏∞Ìôî Ïã§Ìå®: ' + error.message);
            }
        }

        // ÏõπÏ∫† ÏãúÏûë
        async function startWebcam() {
            try {
                // HTTPS Ï≤¥ÌÅ¨
                if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    showError('Camera access requires HTTPS. Please use https:// or localhost');
                    return;
                }

                // MediaDevices API ÏßÄÏõê Ï≤¥ÌÅ¨
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    showError('Your browser does not support camera access. Please use a modern browser (Chrome, Safari, Firefox)');
                    return;
                }

                // Î™®Î∞îÏùº Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú constraints
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                video.srcObject = stream;
                video.addEventListener('loadeddata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    document.getElementById('status').textContent = 'Running';
                    document.getElementById('statusBadge').textContent = 'Active';
                    detectFaces();
                });

                startBtn.disabled = true;
                stopBtn.disabled = false;
            } catch (error) {
                let errorMessage = 'Camera access failed: ';
                
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'Permission denied. Please allow camera access in your browser settings.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'No camera found on this device.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'Camera is already in use by another application.';
                } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
                    errorMessage += 'Camera does not meet the requirements.';
                } else {
                    errorMessage += error.message || 'Unknown error occurred.';
                }
                
                showError(errorMessage);
            }
        }

        // ÏñºÍµ¥ Í∞êÏßÄ Î∞è Î†åÎçîÎßÅ
        function detectFaces() {
            const currentTime = performance.now();
            
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                
                const results = faceLandmarker.detectForVideo(video, currentTime);
                
                // Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ÎπÑÎîîÏò§ ÌîÑÎ†àÏûÑÏùÑ Ï∫îÎ≤ÑÏä§Ïóê Í∑∏Î¶¨Í∏∞
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // ÎûúÎìúÎßàÌÅ¨ Í∑∏Î¶¨Í∏∞ Î∞è Í∞êÏ†ï Ïù∏Ïãù
                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    // Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    let ccallLatency = 0;
                    let latencyTable = [0, 0, 0];
                    
                    // Î∞±ÏóîÎìúÏóê Îî∞Îùº Ï≤òÎ¶¨
                    if (window.appState && window.appState.currentBackend === 'wasm') {
                        // WASM Î∞±ÏóîÎìú: Ïù¥ÎØ∏ÏßÄ Ïò§Î≤ÑÎ†àÏù¥ Ìè¨Ìï®
                        const result = window.processFrame(imageData, results.faceLandmarks);
                        if (result.imageData) {
                            ctx.putImageData(result.imageData, 0, 0);
                        }
                        ccallLatency = result.latency;
                        latencyTable = result.latencyTable || [0, 0, 0];
                    } else if (window.appState && window.appState.currentBackend === 'js' && window.appState.jsBackendReady) {
                        // JS Î∞±ÏóîÎìú: Í∞êÏ†ï Ïù∏Ïãù Î∞è emoji Ïò§Î≤ÑÎ†àÏù¥
                        const aroundFaceCount = window.appState.displayMode === 'flower' ? window.appState.flowerCount : 0;
                        const jsStart = performance.now();
                        const emotionResult = window.processFrameJS(imageData, results.faceLandmarks, aroundFaceCount);
                        ccallLatency = performance.now() - jsStart;
                        
                        if (emotionResult) {
                            // emojiÍ∞Ä Ïò§Î≤ÑÎ†àÏù¥Îêú imageDataÎ•º Ï∫îÎ≤ÑÏä§Ïóê Îã§Ïãú Í∑∏Î¶¨Í∏∞
                            ctx.putImageData(imageData, 0, 0);
                            latencyTable = emotionResult.latencyTable || [0, 0, 0];
                        }
                    }
                    
                    // ccall Î†àÏù¥ÌÑ¥Ïãú ÏóÖÎç∞Ïù¥Ìä∏
                    updateProcessFrameLatency(ccallLatency, results, latencyTable);
                    
                    // ÎûúÎìúÎßàÌÅ¨ Í∑∏Î¶¨Í∏∞ (ÌÜ†Í∏Ä ÏÉÅÌÉúÏóê Îî∞Îùº)
                    if (window.appState.showLandmarks) {
                        drawLandmarks(results.faceLandmarks);
                    }
                } else {
                    // ÏñºÍµ¥Ïù¥ ÏóÜÏùÑ ÎïåÎäî Î†àÏù¥ÌÑ¥ÏãúÎ•º 0ÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
                    updateProcessFrameLatency(0, results, [0, 0, 0]);
                }
            }

            animationId = requestAnimationFrame(detectFaces);
        }

        // ÎûúÎìúÎßàÌÅ¨ Í∑∏Î¶¨Í∏∞
        function drawLandmarks(faces) {
            ctx.fillStyle = 'rgba(33, 128, 141, 0.8)';
            ctx.strokeStyle = 'rgba(33, 128, 141, 0.4)';
            ctx.lineWidth = 1;

            for (const landmarks of faces) {
                // Ï†ê Í∑∏Î¶¨Í∏∞
                for (const landmark of landmarks) {
                    const x = landmark.x * canvas.width;
                    const y = landmark.y * canvas.height;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                }

                // ÏñºÍµ¥ Ïú§Í≥ΩÏÑ† Ïó∞Í≤∞
                const connections = [
                    [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10]
                ];

                for (const connection of connections) {
                    ctx.beginPath();
                    for (let i = 0; i < connection.length - 1; i++) {
                        const start = landmarks[connection[i]];
                        const end = landmarks[connection[i + 1]];
                        
                        ctx.moveTo(start.x * canvas.width, start.y * canvas.height);
                        ctx.lineTo(end.x * canvas.width, end.y * canvas.height);
                    }
                    ctx.stroke();
                }
            }
        }

        // processFrame Î†àÏù¥ÌÑ¥Ïãú Î∞è ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
        function updateProcessFrameLatency(latency, results, latencyTable = [0, 0, 0]) {
            latencyHistory.push(latency);
            if (latencyHistory.length > 30) latencyHistory.shift();
            
            const avgLatency = latencyHistory.reduce((a, b) => a + b, 0) / latencyHistory.length;
            
            document.getElementById('latency').textContent = avgLatency.toFixed(1) + ' ms';
            document.getElementById('processingTime').textContent = avgLatency.toFixed(1) + ' ms';
            const faceCountNum = results.faceLandmarks ? results.faceLandmarks.length : 0;
            document.getElementById('faceCountBadge').textContent = faceCountNum + (faceCountNum === 1 ? ' face' : ' faces');
            
            // Î†àÏù¥ÌÑ¥Ïãú ÌÖåÏù¥Î∏î ÌëúÏãú (Î∞ÄÎ¶¨Ï¥à Îã®ÏúÑÎ°ú Î≥ÄÌôò)
            document.getElementById('landmarkTransformTime').textContent = (latencyTable[0] / 1000).toFixed(3) + ' ms';
            document.getElementById('neuralNetworkTime').textContent = (latencyTable[1] / 1000).toFixed(3) + ' ms';
            document.getElementById('emojiOverlayTime').textContent = (latencyTable[2] / 1000).toFixed(3) + ' ms';
        }

        // ÏõπÏ∫† Ï§ëÏßÄ
        function stopWebcam() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('status').textContent = 'Stopped';
            document.getElementById('statusBadge').textContent = 'Stopped';
            document.getElementById('faceCountBadge').textContent = '0 faces';
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            // ÌÜµÍ≥Ñ Ï¥àÍ∏∞Ìôî
            document.getElementById('latency').textContent = '0 ms';
            
            latencyHistory = [];
            
            // WASM Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ (ÏÑ†ÌÉùÏ†Å - Ïû¨ÏÇ¨Ïö©ÏùÑ ÏúÑÌï¥ Ïú†ÏßÄÌï† ÏàòÎèÑ ÏûàÏùå)
            // freeWASMMemory();
        }

        function showError(message) {
            errorMsg.textContent = message;
            errorMsg.style.display = 'block';
            document.getElementById('status').textContent = 'Error';
            document.getElementById('statusBadge').textContent = 'Error';
        }

        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        startBtn.addEventListener('click', startWebcam);
        stopBtn.addEventListener('click', stopWebcam);

        // Î∏åÎùºÏö∞Ï†Ä Ìò∏ÌôòÏÑ± Ï≤¥ÌÅ¨
        function checkBrowserCompatibility() {
            // HTTPS Ï≤¥ÌÅ¨ (localhostÎäî ÏòàÏô∏)
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                showError('‚ö†Ô∏è HTTPS Required: Camera access requires a secure connection (https://). Please use HTTPS or localhost.');
                startBtn.disabled = true;
                return false;
            }

            // MediaDevices API ÏßÄÏõê Ï≤¥ÌÅ¨
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('‚ö†Ô∏è Browser Not Supported: Your browser does not support camera access. Please use Chrome, Safari, or Firefox.');
                startBtn.disabled = true;
                return false;
            }

            return true;
        }

        // Ï¥àÍ∏∞Ìôî
        document.getElementById('status').textContent = 'Loading...';
        document.getElementById('statusBadge').textContent = 'Loading...';
        
        if (checkBrowserCompatibility()) {
            initMediaPipe();
        }
    </script>
</body>
</html>

